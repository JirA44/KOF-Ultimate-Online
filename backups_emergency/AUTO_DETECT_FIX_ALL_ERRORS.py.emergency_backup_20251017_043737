#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
KOF ULTIMATE - AUTO-D√âTECTEUR ET CORRECTEUR UNIVERSEL
Scanne TOUS les fichiers, d√©tecte TOUTES les erreurs et les corrige automatiquement
"""

import os
import re
import shutil
from pathlib import Path
from datetime import datetime
import subprocess
import json

class UniversalErrorDetectorFixer:
    """D√©tecteur et correcteur universel d'erreurs"""

    def __init__(self):
        self.game_dir = Path(r"D:\KOF Ultimate Online Online Online Online Online Online Online")
        self.correct_game_dir = r"D:\KOF Ultimate Online Online Online Online Online Online Online"
        self.wrong_paths = [
            r"D:\KOF Ultimate Online Online Online Online Online Online",
            r"D:/KOF Ultimate Online Online Online",
            "D:\\KOF Ultimate",
        ]

        self.backup_dir = self.game_dir / "backups_auto_fix"
        self.backup_dir.mkdir(exist_ok=True)

        self.errors_found = []
        self.fixes_applied = []
        self.files_checked = 0
        self.files_fixed = 0

        self.log_file = self.game_dir / "AUTO_FIX_REPORT.txt"

    def log(self, message, level='INFO'):
        """Log un message"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        msg = f"[{timestamp}] [{level}] {message}"
        print(msg)

        with open(self.log_file, 'a', encoding='utf-8') as f:
            f.write(msg + '\n')

    def backup_file(self, filepath):
        """Sauvegarde un fichier avant modification"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_name = f"{filepath.name}.backup_{timestamp}"
            backup_path = self.backup_dir / backup_name
            shutil.copy2(filepath, backup_path)
            return True
        except Exception as e:
            self.log(f"‚ö†Ô∏è  Erreur backup {filepath.name}: {e}", "WARN")
            return False

    def scan_python_file_for_errors(self, filepath):
        """Scanne un fichier Python pour d√©tecter les erreurs"""
        errors = []

        try:
            with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
                lines = content.split('\n')

            # 1. V√©rifier les chemins incorrects
            for wrong_path in self.wrong_paths:
                if wrong_path in content:
                    count = content.count(wrong_path)
                    errors.append({
                        'type': 'WRONG_PATH',
                        'message': f"Chemin incorrect '{wrong_path}' trouv√© {count} fois",
                        'fix': f"Remplacer par '{self.correct_game_dir}'",
                        'auto_fixable': True
                    })

            # 2. V√©rifier les imports manquants/probl√©matiques
            imports_needed = {
                'import tkinter': 'tkinter',
                'import pyautogui': 'pyautogui',
                'import win32gui': 'pywin32',
                'import win32con': 'pywin32',
                'import psutil': 'psutil',
                'from PIL import': 'Pillow',
            }

            for import_line, package in imports_needed.items():
                if import_line in content:
                    # V√©rifier si le package est install√©
                    try:
                        __import__(package if package != 'pywin32' else 'win32gui')
                    except ImportError:
                        errors.append({
                            'type': 'MISSING_PACKAGE',
                            'message': f"Package '{package}' manquant",
                            'fix': f"pip install {package}",
                            'auto_fixable': True
                        })

            # 3. V√©rifier les chemins vers des ex√©cutables inexistants
            exe_patterns = [
                r'["\']([^"\']+\.exe)["\']',
            ]

            for pattern in exe_patterns:
                for match in re.finditer(pattern, content):
                    exe_path = match.group(1)
                    if not Path(exe_path).exists() and not Path(self.game_dir / exe_path).exists():
                        errors.append({
                            'type': 'MISSING_EXE',
                            'message': f"Ex√©cutable introuvable: {exe_path}",
                            'fix': "V√©rifier le chemin ou t√©l√©charger le fichier",
                            'auto_fixable': False
                        })

            # 4. V√©rifier les mkdir sans exist_ok
            if 'mkdir()' in content and 'exist_ok=True' not in content:
                errors.append({
                    'type': 'MKDIR_NO_EXIST_OK',
                    'message': "mkdir() sans exist_ok=True peut causer des erreurs",
                    'fix': "Ajouter exist_ok=True",
                    'auto_fixable': True
                })

            # 5. V√©rifier les input() qui peuvent bloquer
            if 'input(' in content and filepath.name not in ['AUTO_DETECT_FIX_ALL_ERRORS.py']:
                errors.append({
                    'type': 'BLOCKING_INPUT',
                    'message': "input() peut bloquer l'ex√©cution automatique",
                    'fix': "Remplacer par une alternative non-bloquante",
                    'auto_fixable': False
                })

            # 6. V√©rifier les try/except trop larges
            if 'except:' in content or 'except Exception:' in content:
                count = content.count('except:') + content.count('except Exception:')
                if count > 3:
                    errors.append({
                        'type': 'TOO_BROAD_EXCEPT',
                        'message': f"{count} blocs except trop larges",
                        'fix': "Sp√©cifier les exceptions √† capturer",
                        'auto_fixable': False
                    })

            return errors

        except Exception as e:
            self.log(f"‚ùå Erreur scan {filepath.name}: {e}", "ERROR")
            return []

    def fix_python_file(self, filepath, errors):
        """Corrige automatiquement les erreurs d√©tect√©es dans un fichier Python"""
        if not errors:
            return 0

        fixes_count = 0

        try:
            # Backup d'abord
            self.backup_file(filepath)

            with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()

            original_content = content

            for error in errors:
                if not error['auto_fixable']:
                    continue

                if error['type'] == 'WRONG_PATH':
                    # Corriger tous les chemins incorrects
                    for wrong_path in self.wrong_paths:
                        if wrong_path in content:
                            # Remplacer en gardant le format (/ ou \)
                            if '/' in wrong_path:
                                correct = self.correct_game_dir.replace('\\', '/')
                            else:
                                correct = self.correct_game_dir.replace('/', '\\')

                            content = content.replace(wrong_path, correct)
                            fixes_count += 1
                            self.log(f"  ‚úì Corrig√©: {wrong_path} ‚Üí {correct}")

                elif error['type'] == 'MKDIR_NO_EXIST_OK':
                    # Ajouter exist_ok=True aux mkdir()
                    content = re.sub(
                        r'\.mkdir\(\)',
                        '.mkdir(exist_ok=True)',
                        content
                    )
                    fixes_count += 1
                    self.log(f"  ‚úì Corrig√©: mkdir() ‚Üí mkdir(exist_ok=True)")

            # √âcrire les modifications si n√©cessaire
            if content != original_content:
                with open(filepath, 'w', encoding='utf-8') as f:
                    f.write(content)
                self.log(f"  üìù Fichier modifi√©: {filepath.name}")
                self.files_fixed += 1

            return fixes_count

        except Exception as e:
            self.log(f"‚ùå Erreur correction {filepath.name}: {e}", "ERROR")
            return 0

    def scan_all_python_files(self):
        """Scanne tous les fichiers Python du projet"""
        self.log("\nüîç SCAN DE TOUS LES FICHIERS PYTHON")
        self.log("=" * 70)

        python_files = list(self.game_dir.glob("*.py"))

        self.log(f"\nüìÅ {len(python_files)} fichiers Python trouv√©s")
        self.log("")

        all_errors = {}

        for py_file in python_files:
            self.files_checked += 1
            errors = self.scan_python_file_for_errors(py_file)

            if errors:
                all_errors[py_file] = errors
                self.log(f"‚ö†Ô∏è  {py_file.name}: {len(errors)} erreur(s) d√©tect√©e(s)")
                for error in errors:
                    self.errors_found.append({
                        'file': py_file.name,
                        'error': error
                    })
            else:
                self.log(f"‚úÖ {py_file.name}: OK")

        return all_errors

    def fix_all_detected_errors(self, all_errors):
        """Corrige toutes les erreurs d√©tect√©es automatiquement"""
        self.log("\n\nüîß CORRECTION AUTOMATIQUE DES ERREURS")
        self.log("=" * 70)

        if not all_errors:
            self.log("\n‚úÖ Aucune erreur √† corriger!")
            return

        for filepath, errors in all_errors.items():
            self.log(f"\nüìù Correction: {filepath.name}")

            auto_fixable = [e for e in errors if e['auto_fixable']]
            non_fixable = [e for e in errors if not e['auto_fixable']]

            if auto_fixable:
                fixes_count = self.fix_python_file(filepath, auto_fixable)
                self.fixes_applied.append({
                    'file': filepath.name,
                    'fixes': fixes_count
                })

            if non_fixable:
                self.log(f"  ‚ö†Ô∏è  {len(non_fixable)} erreur(s) n√©cessitent une correction manuelle:")
                for error in non_fixable:
                    self.log(f"     ‚Ä¢ {error['message']}")
                    self.log(f"       ‚Üí {error['fix']}")

    def check_mugen_config(self):
        """V√©rifie la configuration MUGEN"""
        self.log("\n\nüéÆ V√âRIFICATION CONFIGURATION MUGEN")
        self.log("=" * 70)

        # V√©rifier system.def
        system_def = self.game_dir / "data" / "system.def"
        if system_def.exists():
            self.log("‚úÖ system.def: Pr√©sent")
        else:
            self.log("‚ùå system.def: MANQUANT!", "ERROR")
            self.errors_found.append({
                'file': 'system.def',
                'error': {'type': 'MISSING_FILE', 'message': 'Fichier system.def manquant'}
            })

        # V√©rifier select.def
        select_def = self.game_dir / "data" / "select.def"
        if select_def.exists():
            self.log("‚úÖ select.def: Pr√©sent")

            # Compter les personnages
            with open(select_def, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
                char_lines = [l for l in content.split('\n') if l.strip() and not l.strip().startswith(';') and 'chars/' in l.lower()]
                self.log(f"   üìä {len(char_lines)} personnages configur√©s")
        else:
            self.log("‚ùå select.def: MANQUANT!", "ERROR")

        # V√©rifier mugen.cfg
        mugen_cfg = self.game_dir / "data" / "mugen.cfg"
        if mugen_cfg.exists():
            self.log("‚úÖ mugen.cfg: Pr√©sent")
        else:
            self.log("‚ö†Ô∏è  mugen.cfg: Manquant", "WARN")

    def check_game_executable(self):
        """V√©rifie les ex√©cutables du jeu"""
        self.log("\n\nüéØ V√âRIFICATION EX√âCUTABLES")
        self.log("=" * 70)

        executables = [
            "KOF_Ultimate_Online.exe",
            "KOF BLACK R.exe",
            "mugen.exe",
        ]

        found_exe = None
        for exe_name in executables:
            exe_path = self.game_dir / exe_name
            if exe_path.exists():
                self.log(f"‚úÖ {exe_name}: Trouv√©")
                if found_exe is None:
                    found_exe = exe_path
            else:
                self.log(f"‚ö†Ô∏è  {exe_name}: Non trouv√©")

        if found_exe:
            self.log(f"\n‚úì Ex√©cutable principal: {found_exe.name}")
        else:
            self.log("\n‚ùå AUCUN EX√âCUTABLE TROUV√â!", "ERROR")
            self.errors_found.append({
                'file': 'game',
                'error': {'type': 'NO_EXECUTABLE', 'message': 'Aucun ex√©cutable de jeu trouv√©'}
            })

    def check_python_packages(self):
        """V√©rifie les packages Python install√©s"""
        self.log("\n\nüì¶ V√âRIFICATION PACKAGES PYTHON")
        self.log("=" * 70)

        required_packages = {
            'tkinter': 'tkinter',
            'pyautogui': 'pyautogui',
            'PIL': 'Pillow',
            'win32gui': 'pywin32',
            'psutil': 'psutil',
        }

        missing = []

        for module_name, package_name in required_packages.items():
            try:
                __import__(module_name)
                self.log(f"‚úÖ {package_name}: Install√©")
            except ImportError:
                self.log(f"‚ùå {package_name}: MANQUANT!", "ERROR")
                missing.append(package_name)
                self.errors_found.append({
                    'file': 'system',
                    'error': {
                        'type': 'MISSING_PACKAGE',
                        'message': f'Package {package_name} manquant',
                        'fix': f'pip install {package_name}',
                        'auto_fixable': True
                    }
                })

        if missing:
            self.log(f"\n‚ö†Ô∏è  Pour installer les packages manquants:")
            self.log(f"   pip install {' '.join(missing)}")

    def install_missing_packages(self):
        """Installe les packages Python manquants"""
        self.log("\n\nüì¶ INSTALLATION PACKAGES MANQUANTS")
        self.log("=" * 70)

        required_packages = {
            'tkinter': None,  # Vient avec Python
            'pyautogui': 'pyautogui',
            'PIL': 'Pillow',
            'win32gui': 'pywin32',
            'psutil': 'psutil',
        }

        to_install = []

        for module_name, package_name in required_packages.items():
            if package_name is None:
                continue

            try:
                __import__(module_name)
            except ImportError:
                to_install.append(package_name)

        if not to_install:
            self.log("‚úÖ Tous les packages sont d√©j√† install√©s!")
            return True

        self.log(f"üì• Installation de {len(to_install)} package(s)...")

        for package in to_install:
            try:
                self.log(f"   Installing {package}...")
                result = subprocess.run(
                    ['pip', 'install', package],
                    capture_output=True,
                    text=True,
                    timeout=60
                )

                if result.returncode == 0:
                    self.log(f"   ‚úÖ {package} install√©!")
                    self.fixes_applied.append({
                        'file': 'system',
                        'fixes': f'Package {package} install√©'
                    })
                else:
                    self.log(f"   ‚ùå √âchec installation {package}", "ERROR")

            except Exception as e:
                self.log(f"   ‚ùå Erreur: {e}", "ERROR")

        return True

    def generate_final_report(self):
        """G√©n√®re le rapport final"""
        self.log("\n\n" + "=" * 70)
        self.log("üìä RAPPORT FINAL")
        self.log("=" * 70)

        self.log(f"\nüìÅ Fichiers scann√©s: {self.files_checked}")
        self.log(f"üîß Fichiers corrig√©s: {self.files_fixed}")
        self.log(f"‚ö†Ô∏è  Erreurs d√©tect√©es: {len(self.errors_found)}")
        self.log(f"‚úÖ Corrections appliqu√©es: {len(self.fixes_applied)}")

        if self.errors_found:
            self.log(f"\nüìã D√âTAILS DES ERREURS:")

            # Grouper par type
            by_type = {}
            for item in self.errors_found:
                error_type = item['error']['type']
                if error_type not in by_type:
                    by_type[error_type] = []
                by_type[error_type].append(item)

            for error_type, items in by_type.items():
                self.log(f"\n  {error_type}: {len(items)} occurrence(s)")
                for item in items[:5]:  # Afficher max 5 exemples
                    self.log(f"    ‚Ä¢ {item['file']}: {item['error']['message']}")
                if len(items) > 5:
                    self.log(f"    ... et {len(items) - 5} autre(s)")

        if self.fixes_applied:
            self.log(f"\n‚úÖ CORRECTIONS APPLIQU√âES:")
            for fix in self.fixes_applied:
                if isinstance(fix['fixes'], int):
                    self.log(f"  ‚Ä¢ {fix['file']}: {fix['fixes']} correction(s)")
                else:
                    self.log(f"  ‚Ä¢ {fix.get('file', 'system')}: {fix['fixes']}")

        self.log(f"\nüíæ Backups: {self.backup_dir}")
        self.log(f"üìÑ Rapport complet: {self.log_file}")

        self.log("\n" + "=" * 70)

        if len(self.errors_found) == 0:
            self.log("‚úÖ AUCUNE ERREUR D√âTECT√âE - SYST√àME OP√âRATIONNEL!")
        elif self.files_fixed > 0:
            self.log("‚úÖ CORRECTIONS APPLIQU√âES - Relancez pour v√©rifier")
        else:
            self.log("‚ö†Ô∏è  ERREURS N√âCESSITANT INTERVENTION MANUELLE")

        self.log("=" * 70)

    def run_full_diagnostic(self):
        """Lance le diagnostic complet"""
        self.log("\n" + "=" * 70)
        self.log("üöÄ AUTO-D√âTECTEUR ET CORRECTEUR UNIVERSEL")
        self.log("=" * 70)
        self.log("\nRecherche et correction automatique de TOUTES les erreurs...")
        self.log("")

        # Nettoyer le log
        if self.log_file.exists():
            self.log_file.unlink()

        # 1. V√©rifier les ex√©cutables
        self.check_game_executable()

        # 2. V√©rifier la config MUGEN
        self.check_mugen_config()

        # 3. V√©rifier les packages Python
        self.check_python_packages()

        # 4. Scanner tous les fichiers Python
        all_errors = self.scan_all_python_files()

        # 5. Corriger les erreurs automatiquement
        self.fix_all_detected_errors(all_errors)

        # 6. Installer les packages manquants
        self.install_missing_packages()

        # 7. G√©n√©rer le rapport final
        self.generate_final_report()

        return len(self.errors_found) == 0

def main():
    """Point d'entr√©e"""
    print("\n" + "=" * 70)
    print("  ü§ñ AUTO-D√âTECTEUR ET CORRECTEUR UNIVERSEL D'ERREURS")
    print("=" * 70)
    print("\n  Ce syst√®me va:")
    print("  ‚Ä¢ Scanner TOUS les fichiers Python")
    print("  ‚Ä¢ D√©tecter TOUTES les erreurs (chemins, imports, config)")
    print("  ‚Ä¢ Corriger AUTOMATIQUEMENT ce qui peut l'√™tre")
    print("  ‚Ä¢ Installer les packages manquants")
    print("  ‚Ä¢ G√©n√©rer un rapport complet")
    print("\n" + "=" * 70)
    print()

    detector = UniversalErrorDetectorFixer()
    success = detector.run_full_diagnostic()

    print("\n\n" + "=" * 70)
    if success:
        print("‚úÖ TOUS LES SYST√àMES OP√âRATIONNELS!")
        print("\nVous pouvez maintenant lancer n'importe quel launcher sans erreur.")
    else:
        print("‚ö†Ô∏è  CORRECTIONS APPLIQU√âES")
        print(f"\nConsultez {detector.log_file} pour les d√©tails.")
        print("\nRelancez ce script pour v√©rifier si toutes les erreurs sont corrig√©es.")
    print("=" * 70)
    print()

if __name__ == '__main__':
    main()
