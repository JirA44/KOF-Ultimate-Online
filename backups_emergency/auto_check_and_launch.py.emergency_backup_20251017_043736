"""
KOF Ultimate - Auto-v√©rification compl√®te avant lancement
V√©rifie tous les √©l√©ments critiques et lance le jeu automatiquement
"""
import os
import re
import subprocess
import sys
from pathlib import Path

class KOFAutoChecker:
    def __init__(self, base_dir=r"D:\KOF Ultimate Online Online Online Online"):
        self.base_dir = Path(base_dir)
        self.errors = []
        self.warnings = []
        self.checks_passed = 0
        self.checks_total = 0

    def check(self, condition, success_msg, error_msg):
        """V√©rifie une condition et log le r√©sultat"""
        self.checks_total += 1
        if condition:
            self.checks_passed += 1
            print(f"  ‚úì {success_msg}")
            return True
        else:
            self.errors.append(error_msg)
            print(f"  ‚úó {error_msg}")
            return False

    def warn(self, condition, success_msg, warning_msg):
        """V√©rifie avec avertissement non bloquant"""
        self.checks_total += 1
        if condition:
            self.checks_passed += 1
            print(f"  ‚úì {success_msg}")
            return True
        else:
            self.warnings.append(warning_msg)
            print(f"  ‚ö† {warning_msg}")
            return False

    def step_1_files_essentiels(self):
        """√âtape 1: Fichiers essentiels du syst√®me"""
        print("\n" + "="*70)
        print("üìÅ √âTAPE 1/6: V√©rification fichiers essentiels")
        print("="*70)

        # Fichiers critiques
        self.check(
            (self.base_dir / "data/system.def").exists(),
            "system.def trouv√©",
            "CRITIQUE: data/system.def manquant!"
        )

        system_sff = self.base_dir / "data/system.sff"
        self.check(
            system_sff.exists(),
            f"system.sff trouv√© ({system_sff.stat().st_size // 1024 // 1024} MB)",
            "CRITIQUE: data/system.sff manquant (sprites du jeu)!"
        )

        self.check(
            (self.base_dir / "data/system.snd").exists(),
            "system.snd trouv√© (sons syst√®me)",
            "CRITIQUE: data/system.snd manquant!"
        )

        self.check(
            (self.base_dir / "data/mugen.cfg").exists(),
            "mugen.cfg trouv√©",
            "CRITIQUE: data/mugen.cfg manquant!"
        )

        self.check(
            (self.base_dir / "data/select.def").exists(),
            "select.def trouv√©",
            "CRITIQUE: data/select.def manquant!"
        )

        exe_file = self.base_dir / "KOF BLACK R.exe"
        self.check(
            exe_file.exists(),
            "KOF BLACK R.exe trouv√©",
            "CRITIQUE: KOF BLACK R.exe manquant!"
        )

    def step_2_configuration_menu(self):
        """√âtape 2: Configuration des menus"""
        print("\n" + "="*70)
        print("üéÆ √âTAPE 2/6: Configuration du menu principal")
        print("="*70)

        system_def = self.base_dir / "data/system.def"
        if not system_def.exists():
            print("  ‚úó Impossible de v√©rifier (system.def manquant)")
            return

        try:
            with open(system_def, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()

            # V√©rifier les items de menu
            menu_items = {
                'arcade': 'Mode Arcade',
                'versus': 'Mode VS (Multijoueur)',
                'teamarcade': 'Team Arcade',
                'training': 'Mode Training',
                'options': 'Options'
            }

            found_items = []
            for key, name in menu_items.items():
                pattern = rf'menu\.itemname\.{key}\s*='
                if re.search(pattern, content, re.IGNORECASE):
                    found_items.append(name)
                    if key == 'versus':
                        print(f"  ‚úì {name} trouv√© dans le menu ‚Üê IMPORTANT!")
                    else:
                        print(f"  ‚úì {name} trouv√©")

            self.check(
                'Mode VS (Multijoueur)' in found_items,
                "",  # D√©j√† affich√© ci-dessus
                "ERREUR: Mode VS manquant dans menu!"
            )

            self.check(
                len(found_items) >= 3,
                f"{len(found_items)} modes de jeu disponibles",
                f"Seulement {len(found_items)} modes trouv√©s"
            )

        except Exception as e:
            print(f"  ‚úó Erreur lecture system.def: {e}")

    def step_3_sprites_et_animations(self):
        """√âtape 3: Sprites et animations"""
        print("\n" + "="*70)
        print("üé® √âTAPE 3/6: Sprites et animations de fond")
        print("="*70)

        system_def = self.base_dir / "data/system.def"
        if not system_def.exists():
            print("  ‚úó Impossible de v√©rifier")
            return

        try:
            with open(system_def, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()

            # V√©rifier TitleBG
            has_titlebg = '[TitleBGdef]' in content or '[TitleBG' in content
            self.check(
                has_titlebg,
                "Configuration TitleBG trouv√©e (fond anim√© du menu)",
                "Configuration TitleBG manquante"
            )

            # V√©rifier animations
            anim_pattern = r'actionno\s*=\s*\d+'
            animations = re.findall(anim_pattern, content)
            self.check(
                len(animations) > 0,
                f"{len(animations)} animations d√©finies dans system.def",
                "Aucune animation trouv√©e"
            )

            # V√©rifier sprites
            sprite_pattern = r'spriteno\s*=\s*[\d,]+'
            sprites = re.findall(sprite_pattern, content)
            self.check(
                len(sprites) > 0,
                f"{len(sprites)} sprites d√©finis pour le fond",
                "Aucun sprite de fond trouv√©"
            )

        except Exception as e:
            print(f"  ‚úó Erreur analyse sprites: {e}")

    def step_4_personnages(self):
        """√âtape 4: Personnages"""
        print("\n" + "="*70)
        print("üë• √âTAPE 4/6: Personnages disponibles")
        print("="*70)

        chars_dir = self.base_dir / "chars"
        self.check(
            chars_dir.exists() and chars_dir.is_dir(),
            "Dossier chars/ trouv√©",
            "Dossier chars/ manquant!"
        )

        if chars_dir.exists():
            char_folders = [d for d in chars_dir.iterdir() if d.is_dir()]
            self.check(
                len(char_folders) > 0,
                f"{len(char_folders)} personnages d√©tect√©s",
                "Aucun personnage trouv√©!"
            )

        # V√©rifier select.def
        select_def = self.base_dir / "data/select.def"
        if select_def.exists():
            try:
                with open(select_def, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()

                chars_section = re.search(r'\[Characters\](.*?)(?:\[|$)', content, re.DOTALL | re.IGNORECASE)
                if chars_section:
                    char_lines = [line.strip() for line in chars_section.group(1).split('\n')
                                 if line.strip() and not line.strip().startswith(';')]
                    self.check(
                        len(char_lines) > 10,
                        f"{len(char_lines)} personnages dans select.def",
                        f"Seulement {len(char_lines)} personnages dans select.def"
                    )
            except Exception as e:
                print(f"  ‚ö† Erreur lecture select.def: {e}")

    def step_5_config_manettes(self):
        """√âtape 5: Configuration manettes"""
        print("\n" + "="*70)
        print("üéÆ √âTAPE 5/6: Configuration des manettes")
        print("="*70)

        mugen_cfg = self.base_dir / "data/mugen.cfg"
        if not mugen_cfg.exists():
            print("  ‚úó Impossible de v√©rifier")
            return

        try:
            with open(mugen_cfg, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()

            # V√©rifier P1
            p1_joy_pattern = r'p1\.joystick\s*=\s*\d+'
            has_p1_joy = re.search(p1_joy_pattern, content, re.IGNORECASE)
            self.check(
                has_p1_joy is not None,
                "Configuration P1 joystick trouv√©e",
                "Configuration P1 joystick manquante"
            )

            # V√©rifier P2
            p2_joy_pattern = r'p2\.joystick\s*=\s*\d+'
            has_p2_joy = re.search(p2_joy_pattern, content, re.IGNORECASE)
            self.warn(
                has_p2_joy is not None,
                "Configuration P2 joystick trouv√©e",
                "Configuration P2 joystick manquante (P2 devra utiliser clavier)"
            )

            # V√©rifier sections [P1 Joystick] et [P2 Joystick]
            self.check(
                '[P1 Joystick]' in content,
                "Section [P1 Joystick] pr√©sente",
                "Section [P1 Joystick] manquante"
            )

            self.warn(
                '[P2 Joystick]' in content,
                "Section [P2 Joystick] pr√©sente",
                "Section [P2 Joystick] manquante"
            )

        except Exception as e:
            print(f"  ‚úó Erreur lecture mugen.cfg: {e}")

    def step_6_musique(self):
        """√âtape 6: Musique et sons"""
        print("\n" + "="*70)
        print("üéµ √âTAPE 6/6: Musique et fichiers audio")
        print("="*70)

        # V√©rifier musique titre
        music_files = [
            "data/musica/MENU SCREEN.mp3",
            "data/musica/SELECT SCREEN.mp3",
            "data/musica/VS SCREEN.mp3"
        ]

        for music_file in music_files:
            music_path = self.base_dir / music_file
            if music_path.exists():
                size_kb = music_path.stat().st_size // 1024
                self.check(
                    True,
                    f"{music_file.split('/')[-1]} trouv√© ({size_kb} KB)",
                    ""
                )
            else:
                self.warn(
                    False,
                    "",
                    f"{music_file.split('/')[-1]} manquant (pas critique)"
                )

    def generate_report(self):
        """G√©n√®re le rapport final"""
        print("\n" + "="*70)
        print("üìä RAPPORT FINAL")
        print("="*70)

        score = (self.checks_passed / self.checks_total * 100) if self.checks_total > 0 else 0

        print(f"\n‚úÖ V√©rifications r√©ussies: {self.checks_passed}/{self.checks_total}")
        print(f"üìä Score: {score:.1f}%")

        if len(self.warnings) > 0:
            print(f"\n‚ö†Ô∏è  Avertissements ({len(self.warnings)}):")
            for warn in self.warnings:
                print(f"   - {warn}")

        if len(self.errors) > 0:
            print(f"\n‚ùå Erreurs critiques ({len(self.errors)}):")
            for err in self.errors:
                print(f"   - {err}")

            print("\n" + "="*70)
            print("‚ö†Ô∏è  ATTENTION: Erreurs critiques d√©tect√©es!")
            print("   Le jeu pourrait ne pas fonctionner correctement.")
            print("="*70)
            return False
        elif len(self.warnings) > 0:
            print("\n" + "="*70)
            print("‚úÖ Le jeu est pr√™t avec quelques avertissements mineurs")
            print("="*70)
            return True
        else:
            print("\n" + "="*70)
            print("üéâ PARFAIT! Tous les tests pass√©s!")
            print("="*70)
            return True

    def launch_game(self):
        """Lance le jeu"""
        print("\n" + "="*70)
        print("üöÄ LANCEMENT DU JEU")
        print("="*70)

        game_exe = self.base_dir / "KOF BLACK R.exe"

        if not game_exe.exists():
            print(f"\n‚ùå ERREUR: {game_exe} introuvable!")
            return False

        print(f"\nLancement de: {game_exe.name}")
        print("Patientez...")

        try:
            subprocess.Popen([str(game_exe)], cwd=str(self.base_dir))
            print("\n‚úÖ Jeu lanc√© avec succ√®s!")
            return True
        except Exception as e:
            print(f"\n‚ùå ERREUR lors du lancement: {e}")
            return False

    def run(self, auto_launch=True):
        """Ex√©cute toutes les v√©rifications"""
        print("="*70)
        print("  KOF ULTIMATE - AUTO-V√âRIFICATION COMPL√àTE")
        print("="*70)

        # Ex√©cuter toutes les √©tapes
        self.step_1_files_essentiels()
        self.step_2_configuration_menu()
        self.step_3_sprites_et_animations()
        self.step_4_personnages()
        self.step_5_config_manettes()
        self.step_6_musique()

        # Rapport final
        success = self.generate_report()

        # Lancer le jeu si demand√©
        if auto_launch:
            if success or len(self.errors) == 0:
                print("\n")
                response = input("Lancer le jeu maintenant? (O/n): ")
                if response.lower() != 'n':
                    self.launch_game()
            else:
                print("\n‚ö†Ô∏è  Lancement annul√© √† cause des erreurs critiques.")
                print("   Corrigez les probl√®mes avant de lancer le jeu.")

        print("\n" + "="*70)
        return success

if __name__ == "__main__":
    checker = KOFAutoChecker()
    checker.run(auto_launch=True)

    input("\nAppuyez sur Entr√©e pour quitter...")
