# -*- coding: utf-8 -*-
"""
Exploration complÃ¨te du systÃ¨me KOF avec tous les agents IA
"""

import os
import sys
import subprocess
import time
from pathlib import Path
import json

class AIExplorationSystem:
    def __init__(self):
        self.base_dir = Path(r'D:\KOF Ultimate Online Online Online Online Online')
        self.results = {
            'system_test': None,
            'game_monitor': None,
            'error_analysis': None,
            'file_integrity': None
        }

    def print_header(self, text):
        print(f"\n{'='*80}")
        print(f"  {text}")
        print(f"{'='*80}\n")

    def run_system_test(self):
        """ExÃ©cute le test systÃ¨me complet"""
        self.print_header("ðŸ” IA 1: TESTS SYSTÃˆME COMPLETS")

        try:
            result = subprocess.run(
                ['python', 'test_complet_systeme.py'],
                cwd=self.base_dir,
                capture_output=True,
                text=True,
                timeout=60
            )

            print(result.stdout)
            self.results['system_test'] = {
                'status': 'SUCCESS' if result.returncode == 0 else 'FAILED',
                'output': result.stdout
            }

            return result.returncode == 0

        except Exception as e:
            print(f"âŒ Erreur: {e}")
            self.results['system_test'] = {'status': 'ERROR', 'error': str(e)}
            return False

    def analyze_errors(self):
        """Analyse les logs d'erreurs existants"""
        self.print_header("ðŸ” IA 2: ANALYSE DES ERREURS")

        log_file = self.base_dir / 'mugen.log'

        if not log_file.exists():
            print("âœ“ Aucun log d'erreur trouvÃ© - SystÃ¨me propre!")
            self.results['error_analysis'] = {'status': 'CLEAN', 'errors': 0}
            return True

        try:
            result = subprocess.run(
                ['python', 'realtime_error_monitor.py', '--analyze'],
                cwd=self.base_dir,
                capture_output=True,
                text=True,
                timeout=30
            )

            print(result.stdout)
            self.results['error_analysis'] = {
                'status': 'COMPLETED',
                'output': result.stdout
            }

            return True

        except Exception as e:
            print(f"âŒ Erreur: {e}")
            return False

    def check_file_integrity(self):
        """VÃ©rifie l'intÃ©gritÃ© de tous les fichiers"""
        self.print_header("ðŸ” IA 3: INTÃ‰GRITÃ‰ DES FICHIERS")

        issues = []

        # 1. VÃ©rifier l'exÃ©cutable
        exe_files = [
            'KOF_Ultimate_Online.exe',
            'KOF BLACK R.exe'
        ]

        exe_found = None
        for exe in exe_files:
            if (self.base_dir / exe).exists():
                exe_found = exe
                print(f"âœ“ ExÃ©cutable trouvÃ©: {exe}")
                break

        if not exe_found:
            issues.append("Aucun exÃ©cutable de jeu trouvÃ©!")
            print("âŒ Aucun exÃ©cutable trouvÃ©")

        # 2. VÃ©rifier les fichiers systÃ¨me
        system_files = [
            'data/system.def',
            'data/select.def',
            'data/system.sff',
            'data/system.snd'
        ]

        for file in system_files:
            filepath = self.base_dir / file
            if filepath.exists():
                size = filepath.stat().st_size
                print(f"âœ“ {file}: {size:,} bytes")
            else:
                issues.append(f"Fichier manquant: {file}")
                print(f"âŒ Manquant: {file}")

        # 3. VÃ©rifier les personnages
        chars_dir = self.base_dir / 'chars'
        if chars_dir.exists():
            char_folders = [f for f in chars_dir.iterdir() if f.is_dir()]
            print(f"âœ“ {len(char_folders)} dossiers de personnages")

            # VÃ©rifier les 10 premiers
            broken_chars = []
            for char_folder in list(char_folders)[:10]:
                def_files = list(char_folder.glob('*.def'))
                if not def_files:
                    broken_chars.append(char_folder.name)

            if broken_chars:
                print(f"âš ï¸  {len(broken_chars)} personnages sans fichier .def")
                issues.append(f"{len(broken_chars)} personnages incomplets")

        # 4. VÃ©rifier les stages
        stages_dir = self.base_dir / 'stages'
        if stages_dir.exists():
            stage_files = list(stages_dir.glob('*.def'))
            print(f"âœ“ {len(stage_files)} stages")

        # 5. VÃ©rifier la documentation
        docs = [
            'VISUALISEUR_PERSONNAGES.html',
            'FICHES_PERSONNAGES/INDEX.md'
        ]

        for doc in docs:
            if (self.base_dir / doc).exists():
                print(f"âœ“ Documentation: {doc}")
            else:
                print(f"âš ï¸  Documentation manquante: {doc}")

        self.results['file_integrity'] = {
            'status': 'COMPLETED',
            'issues_found': len(issues),
            'issues': issues
        }

        return len(issues) == 0

    def fix_config_paths(self):
        """Corrige les chemins d'exÃ©cutable dans les configs"""
        self.print_header("ðŸ”§ IA 4: CORRECTION DES CONFIGURATIONS")

        # DÃ©tecter le bon exÃ©cutable
        exe_name = None
        for exe in ['KOF_Ultimate_Online.exe', 'KOF BLACK R.exe']:
            if (self.base_dir / exe).exists():
                exe_name = exe
                break

        if not exe_name:
            print("âŒ Aucun exÃ©cutable trouvÃ© pour configurer")
            return False

        print(f"âœ“ ExÃ©cutable dÃ©tectÃ©: {exe_name}")

        # Corriger game_monitor.py
        monitor_file = self.base_dir / 'game_monitor.py'
        if monitor_file.exists():
            try:
                with open(monitor_file, 'r', encoding='utf-8') as f:
                    content = f.read()

                # Remplacer le nom d'exÃ©cutable
                old_names = ['KOF BLACK R.exe', 'KOF_Ultimate_Online.exe']
                for old_name in old_names:
                    if old_name != exe_name and old_name in content:
                        content = content.replace(old_name, exe_name)
                        print(f"  â†’ Remplacement: {old_name} â†’ {exe_name}")

                with open(monitor_file, 'w', encoding='utf-8') as f:
                    f.write(content)

                print("âœ“ game_monitor.py corrigÃ©")

            except Exception as e:
                print(f"âŒ Erreur correction game_monitor.py: {e}")

        return True

    def generate_report(self):
        """GÃ©nÃ¨re le rapport final"""
        self.print_header("ðŸ“Š RAPPORT FINAL D'EXPLORATION IA")

        # Compter les rÃ©sultats
        total_tests = len(self.results)
        successful = sum(1 for r in self.results.values() if r and r.get('status') in ['SUCCESS', 'CLEAN', 'COMPLETED'])

        print(f"Tests effectuÃ©s: {total_tests}")
        print(f"RÃ©ussis: {successful}/{total_tests}")
        print()

        # DÃ©tails par test
        for test_name, result in self.results.items():
            if result:
                status_emoji = {
                    'SUCCESS': 'âœ…',
                    'CLEAN': 'âœ…',
                    'COMPLETED': 'âœ…',
                    'FAILED': 'âŒ',
                    'ERROR': 'âŒ'
                }.get(result.get('status'), 'âš ï¸')

                print(f"{status_emoji} {test_name.upper()}: {result.get('status')}")

                if 'issues_found' in result:
                    print(f"   Issues: {result['issues_found']}")
                    if result['issues']:
                        for issue in result['issues']:
                            print(f"     - {issue}")

        print()

        # Recommandations
        has_issues = any(
            r and r.get('status') in ['FAILED', 'ERROR'] or r.get('issues_found', 0) > 0
            for r in self.results.values()
        )

        if has_issues:
            print("ðŸ”§ ACTIONS RECOMMANDÃ‰ES:")
            print("  1. Relancer les tests aprÃ¨s corrections")
            print("  2. VÃ©rifier le fichier mugen.log si des erreurs apparaissent")
            print("  3. Utiliser launch_complete_system.bat pour dÃ©marrer avec monitoring")
        else:
            print("âœ… SYSTÃˆME PRÃŠT!")
            print("  â†’ Tous les tests sont passÃ©s")
            print("  â†’ Le jeu peut Ãªtre lancÃ© en toute sÃ©curitÃ©")
            print("  â†’ Utilise launch_complete_system.bat pour dÃ©marrer")

        # Sauvegarder le rapport
        report_file = self.base_dir / 'ai_exploration_report.json'
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(self.results, f, indent=2, ensure_ascii=False)

        print(f"\nðŸ“„ Rapport sauvegardÃ©: {report_file}")

    def run_full_exploration(self):
        """Lance l'exploration complÃ¨te"""
        print("\n" + "="*80)
        print("  ðŸ¤– EXPLORATION COMPLÃˆTE DU SYSTÃˆME AVEC AGENTS IA")
        print("="*80)

        # ExÃ©cuter tous les tests
        self.run_system_test()
        self.analyze_errors()
        self.check_file_integrity()
        self.fix_config_paths()

        # Rapport final
        self.generate_report()

def main():
    explorer = AIExplorationSystem()
    explorer.run_full_exploration()

    print("\n" + "="*80)
    input("Appuyez sur EntrÃ©e pour fermer...")

if __name__ == '__main__':
    main()
