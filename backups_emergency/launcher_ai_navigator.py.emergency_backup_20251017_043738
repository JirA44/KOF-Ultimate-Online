"""
KOF Ultimate - Agent IA Navigateur
Version 1.0.0

Cet agent navigue automatiquement sur le launcher en parall√®le
pour d√©tecter et signaler tous les probl√®mes.
"""

import os
import sys
import time
import json
from datetime import datetime
from pathlib import Path
import tkinter as tk
from tkinter import ttk
import pyautogui
try:
    import anthropic
    ANTHROPIC_AVAILABLE = True
except:
    ANTHROPIC_AVAILABLE = False
from PIL import Image, ImageDraw, ImageFont
import threading
import numpy as np

# Configuration
ANTHROPIC_API_KEY = os.getenv("ANTHROPIC_API_KEY")
if not ANTHROPIC_API_KEY:
    print("‚ö†Ô∏è  ANTHROPIC_API_KEY not found in environment variables")
    print("Please set it with: set ANTHROPIC_API_KEY=your_key_here")
    print("Continuing with limited functionality (basic checks only)...")

GAME_PATH = Path("D:/KOF Ultimate Online Online")
LOG_FILE = GAME_PATH / "launcher_ai_log.json"

class LauncherAINavigator:
    """Agent IA qui navigue sur le launcher et d√©tecte les probl√®mes"""

    def __init__(self):
        self.client = anthropic.Anthropic(api_key=ANTHROPIC_API_KEY) if (ANTHROPIC_API_KEY and ANTHROPIC_AVAILABLE) else None
        self.problems_detected = []
        self.navigation_log = []
        self.running = False

        # Interface de monitoring
        self.root = tk.Tk()
        self.root.title("ü§ñ KOF Ultimate - AI Navigator")
        self.root.geometry("500x700")
        self.root.configure(bg='#1a1f3a')

        self.setup_ui()

        # D√©marrer automatiquement le monitoring apr√®s 1 seconde
        self.root.after(1000, self.start_monitoring)

    def setup_ui(self):
        """Configure l'interface de l'agent"""
        # Header
        header = tk.Frame(self.root, bg='#0d1b2a', height=80)
        header.pack(fill=tk.X)
        header.pack_propagate(False)

        title = tk.Label(
            header,
            text="ü§ñ  AI NAVIGATOR",
            font=('Consolas', 20, 'bold'),
            fg='#00ff88',
            bg='#0d1b2a'
        )
        title.pack(pady=20)

        # Status
        self.status_frame = tk.Frame(self.root, bg='#1a1f3a', padx=20, pady=10)
        self.status_frame.pack(fill=tk.X)

        self.status_label = tk.Label(
            self.status_frame,
            text="‚ö° Status: Initializing...",
            font=('Consolas', 11, 'bold'),
            fg='#ffff00',
            bg='#1a1f3a',
            anchor=tk.W
        )
        self.status_label.pack(fill=tk.X)

        # Statistiques
        stats_frame = tk.LabelFrame(
            self.root,
            text=" üìä  STATISTICS ",
            font=('Consolas', 10, 'bold'),
            fg='#00d9ff',
            bg='#1b263b',
            padx=15,
            pady=10
        )
        stats_frame.pack(fill=tk.X, padx=20, pady=10)

        self.stats_text = tk.Text(
            stats_frame,
            height=5,
            font=('Consolas', 9),
            bg='#0d1b2a',
            fg='#c0c0c0',
            relief=tk.FLAT,
            padx=10,
            pady=5
        )
        self.stats_text.pack(fill=tk.BOTH)
        self.update_stats()

        # Log de navigation
        log_frame = tk.LabelFrame(
            self.root,
            text=" üó∫Ô∏è  NAVIGATION LOG ",
            font=('Consolas', 10, 'bold'),
            fg='#00d9ff',
            bg='#1b263b',
            padx=15,
            pady=10
        )
        log_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        # Scrollbar pour le log
        scrollbar = tk.Scrollbar(log_frame)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        self.log_text = tk.Text(
            log_frame,
            font=('Consolas', 9),
            bg='#0d1b2a',
            fg='#00ff88',
            relief=tk.FLAT,
            yscrollcommand=scrollbar.set,
            padx=10,
            pady=5
        )
        self.log_text.pack(fill=tk.BOTH, expand=True)
        scrollbar.config(command=self.log_text.yview)

        # Probl√®mes d√©tect√©s
        problems_frame = tk.LabelFrame(
            self.root,
            text=" ‚ö†Ô∏è  PROBLEMS DETECTED ",
            font=('Consolas', 10, 'bold'),
            fg='#ff4444',
            bg='#1b263b',
            padx=15,
            pady=10
        )
        problems_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)

        problems_scrollbar = tk.Scrollbar(problems_frame)
        problems_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        self.problems_text = tk.Text(
            problems_frame,
            font=('Consolas', 9),
            bg='#0d1b2a',
            fg='#ff6666',
            relief=tk.FLAT,
            yscrollcommand=problems_scrollbar.set,
            padx=10,
            pady=5
        )
        self.problems_text.pack(fill=tk.BOTH, expand=True)
        problems_scrollbar.config(command=self.problems_text.yview)

        # Boutons de contr√¥le
        controls = tk.Frame(self.root, bg='#1a1f3a', padx=20, pady=10)
        controls.pack(fill=tk.X)

        self.start_btn = tk.Button(
            controls,
            text="‚ñ∂ START MONITORING",
            font=('Consolas', 11, 'bold'),
            bg='#00cc44',
            fg='#000000',
            command=self.start_monitoring,
            padx=20,
            pady=8,
            relief=tk.RAISED,
            bd=3,
            cursor='hand2'
        )
        self.start_btn.pack(side=tk.LEFT, padx=5)

        self.stop_btn = tk.Button(
            controls,
            text="‚èπ STOP",
            font=('Consolas', 11, 'bold'),
            bg='#cc0000',
            fg='#ffffff',
            command=self.stop_monitoring,
            padx=20,
            pady=8,
            relief=tk.RAISED,
            bd=3,
            cursor='hand2',
            state=tk.DISABLED
        )
        self.stop_btn.pack(side=tk.LEFT, padx=5)

        save_btn = tk.Button(
            controls,
            text="üíæ SAVE LOG",
            font=('Consolas', 10, 'bold'),
            bg='#0066cc',
            fg='#ffffff',
            command=self.save_log,
            padx=15,
            pady=8,
            relief=tk.RAISED,
            bd=3,
            cursor='hand2'
        )
        save_btn.pack(side=tk.RIGHT, padx=5)

    def log_message(self, message, level="INFO"):
        """Ajoute un message au log"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        colors = {
            "INFO": "#00ff88",
            "WARNING": "#ffaa00",
            "ERROR": "#ff4444",
            "SUCCESS": "#00ff00"
        }

        log_entry = {
            "timestamp": timestamp,
            "level": level,
            "message": message
        }
        self.navigation_log.append(log_entry)

        # Afficher dans l'interface
        self.log_text.config(state=tk.NORMAL)
        self.log_text.insert(tk.END, f"[{timestamp}] ", "timestamp")
        self.log_text.insert(tk.END, f"{level}: ", level)
        self.log_text.insert(tk.END, f"{message}\n", "message")

        # Configuration des tags
        self.log_text.tag_config("timestamp", foreground="#888888")
        self.log_text.tag_config(level, foreground=colors.get(level, "#ffffff"))
        self.log_text.tag_config("message", foreground="#c0c0c0")

        self.log_text.see(tk.END)
        self.log_text.config(state=tk.DISABLED)

    def add_problem(self, problem_description, severity="MEDIUM"):
        """Ajoute un probl√®me d√©tect√©"""
        problem = {
            "timestamp": datetime.now().isoformat(),
            "severity": severity,
            "description": problem_description
        }
        self.problems_detected.append(problem)

        # Afficher dans l'interface
        self.problems_text.config(state=tk.NORMAL)
        severity_emoji = {"HIGH": "üî¥", "MEDIUM": "üü†", "LOW": "üü°"}
        self.problems_text.insert(
            tk.END,
            f"{severity_emoji.get(severity, '‚ö™')} [{severity}] {problem_description}\n\n"
        )
        self.problems_text.see(tk.END)
        self.problems_text.config(state=tk.DISABLED)

        self.update_stats()

    def update_stats(self):
        """Met √† jour les statistiques"""
        ai_status = "‚úì Claude AI" if self.client else "‚úì Basic Mode (no API)"
        stats = f"""
Actions effectu√©es:  {len(self.navigation_log)}
Probl√®mes d√©tect√©s:  {len(self.problems_detected)}
Temps d'ex√©cution:   {self.get_runtime()}
Statut IA:          {ai_status}
        """

        self.stats_text.config(state=tk.NORMAL)
        self.stats_text.delete(1.0, tk.END)
        self.stats_text.insert(1.0, stats)
        self.stats_text.config(state=tk.DISABLED)

    def get_runtime(self):
        """Calcule le temps d'ex√©cution"""
        if not hasattr(self, 'start_time'):
            return "00:00:00"

        elapsed = int(time.time() - self.start_time)
        hours = elapsed // 3600
        minutes = (elapsed % 3600) // 60
        seconds = elapsed % 60
        return f"{hours:02d}:{minutes:02d}:{seconds:02d}"

    def capture_screen(self):
        """Capture l'√©cran actuel"""
        try:
            screenshot = pyautogui.screenshot()
            return screenshot
        except Exception as e:
            self.log_message(f"Failed to capture screen: {e}", "ERROR")
            return None

    def analyze_with_claude(self, screenshot):
        """Analyse le screenshot avec Claude"""
        if not self.client:
            return "Claude API not available"

        try:
            # Sauvegarder temporairement l'image
            temp_path = GAME_PATH / "temp_screenshot.png"
            screenshot.save(temp_path)

            # Lire l'image en base64
            import base64
            with open(temp_path, "rb") as f:
                image_data = base64.b64encode(f.read()).decode()

            # Analyser avec Claude
            message = self.client.messages.create(
                model="claude-3-5-sonnet-20241022",
                max_tokens=1024,
                messages=[{
                    "role": "user",
                    "content": [
                        {
                            "type": "image",
                            "source": {
                                "type": "base64",
                                "media_type": "image/png",
                                "data": image_data
                            }
                        },
                        {
                            "type": "text",
                            "text": """Analyse cette capture d'√©cran du launcher KOF Ultimate.

Identifie :
1. Tous les boutons visibles et leurs √©tats
2. Les probl√®mes potentiels (messages d'erreur, √©l√©ments manquants, etc.)
3. L'√©tat actuel de l'interface
4. Les actions recommand√©es

R√©ponds en fran√ßais de mani√®re concise."""
                        }
                    ]
                }]
            )

            # Nettoyer
            temp_path.unlink()

            return message.content[0].text

        except Exception as e:
            self.log_message(f"Claude analysis failed: {e}", "ERROR")
            return f"Analysis error: {e}"

    def check_launcher_window(self):
        """V√©rifie si la fen√™tre du launcher est ouverte"""
        try:
            # Rechercher plusieurs titres possibles
            possible_titles = [
                "KOF Ultimate Launcher",
                "KOF Ultimate",
                "launcher.py",
                "Python"
            ]
            for title in possible_titles:
                windows = pyautogui.getWindowsWithTitle(title)
                if len(windows) > 0:
                    self.log_message(f"Found window: {title}", "SUCCESS")
                    return True
            return False
        except Exception as e:
            self.log_message(f"Error checking window: {e}", "ERROR")
            return False

    def start_monitoring(self):
        """D√©marre le monitoring"""
        self.start_time = time.time()
        self.running = True
        self.start_btn.config(state=tk.DISABLED)
        self.stop_btn.config(state=tk.NORMAL)
        self.status_label.config(text="‚ö° Status: Monitoring active...", fg="#00ff00")

        # D√©marrer dans un thread s√©par√©
        thread = threading.Thread(target=self.monitoring_loop, daemon=True)
        thread.start()

    def stop_monitoring(self):
        """Arr√™te le monitoring"""
        self.running = False
        self.start_btn.config(state=tk.NORMAL)
        self.stop_btn.config(state=tk.DISABLED)
        self.status_label.config(text="‚ö° Status: Stopped", fg="#ffaa00")
        self.log_message("Monitoring stopped by user", "INFO")

    def monitoring_loop(self):
        """Boucle principale de monitoring"""
        self.log_message("Starting AI navigation monitoring", "SUCCESS")

        iteration = 0
        while self.running:
            iteration += 1
            self.log_message(f"--- Iteration {iteration} ---", "INFO")

            # V√©rifier si le launcher est ouvert
            if not self.check_launcher_window():
                self.log_message("Launcher window not found", "WARNING")
                self.add_problem("Launcher window is not open", "LOW")
                time.sleep(5)
                continue

            # Capturer l'√©cran
            self.log_message("Capturing screen...", "INFO")
            screenshot = self.capture_screen()

            if screenshot:
                # Analyser avec Claude (si disponible)
                if self.client:
                    self.log_message("Analyzing with Claude AI...", "INFO")
                    analysis = self.analyze_with_claude(screenshot)
                    self.log_message(f"Analysis result: {analysis[:100]}...", "SUCCESS")

                    # D√©tecter les probl√®mes dans l'analyse
                    if "erreur" in analysis.lower() or "error" in analysis.lower():
                        self.add_problem(f"Detected error in UI: {analysis[:200]}", "HIGH")
                    elif "warning" in analysis.lower() or "attention" in analysis.lower():
                        self.add_problem(f"Warning detected: {analysis[:200]}", "MEDIUM")
                else:
                    self.log_message("Claude API not available, basic checks only", "WARNING")

                # V√©rifications basiques
                self.perform_basic_checks()

            # Mettre √† jour les stats
            self.root.after(0, self.update_stats)

            # Attendre avant la prochaine it√©ration
            time.sleep(10)

        self.log_message("Monitoring loop ended", "INFO")

    def perform_basic_checks(self):
        """Effectue des v√©rifications basiques sans IA"""
        # V√©rifier les fichiers essentiels
        essential_files = [
            GAME_PATH / "KOF_Ultimate_Online.exe",
            GAME_PATH / "data" / "mugen.cfg",
            GAME_PATH / "launcher.py"
        ]

        for file_path in essential_files:
            if not file_path.exists():
                self.add_problem(f"Missing essential file: {file_path.name}", "HIGH")
                self.log_message(f"Missing file: {file_path}", "ERROR")
            else:
                self.log_message(f"‚úì File found: {file_path.name}", "SUCCESS")

        # Navigation automatique dans l'interface
        self.navigate_interface()

    def navigate_interface(self):
        """Navigue automatiquement dans l'interface du launcher"""
        try:
            self.log_message("üöÄ Starting interface navigation...", "INFO")

            # Capturer l'√©cran pour analyser
            screenshot = self.capture_screen()
            if not screenshot:
                return

            # Convertir en numpy pour analyse d'image
            import numpy as np
            screen = np.array(screenshot)

            # D√©tecter les couleurs de boutons (vert, bleu, rouge, etc.)
            # Vert pour les boutons actifs
            green_mask = (screen[:,:,1] > 150) & (screen[:,:,0] < 100) & (screen[:,:,2] < 100)

            if np.any(green_mask):
                self.log_message("‚úì Detected green buttons (active elements)", "SUCCESS")
                # Trouver le centre du bouton vert
                y_coords, x_coords = np.where(green_mask)
                if len(x_coords) > 0:
                    center_x = int(np.mean(x_coords))
                    center_y = int(np.mean(y_coords))
                    self.log_message(f"  ‚Üí Button position: ({center_x}, {center_y})", "INFO")

            # D√©tecter si des fen√™tres d'erreur sont pr√©sentes (rouge)
            red_mask = (screen[:,:,0] > 180) & (screen[:,:,1] < 100) & (screen[:,:,2] < 100)
            if np.any(red_mask):
                self.add_problem("Detected red elements - possible error dialog", "MEDIUM")
                self.log_message("‚ö†Ô∏è  Red elements detected (possible error)", "WARNING")

            # D√©tecter les zones de texte blanc/gris (labels)
            text_mask = (screen[:,:,0] > 200) & (screen[:,:,1] > 200) & (screen[:,:,2] > 200)
            text_pixels = np.sum(text_mask)
            self.log_message(f"  ‚Üí Text pixels detected: {text_pixels}", "INFO")

            if text_pixels < 1000:
                self.add_problem("Very little text detected - interface may not be loaded", "LOW")

            self.log_message("‚úì Interface navigation completed", "SUCCESS")

        except Exception as e:
            self.log_message(f"Navigation error: {e}", "ERROR")
            # Continuer m√™me en cas d'erreur
            pass

    def save_log(self):
        """Sauvegarde le log complet"""
        log_data = {
            "timestamp": datetime.now().isoformat(),
            "runtime": self.get_runtime(),
            "navigation_log": self.navigation_log,
            "problems_detected": self.problems_detected
        }

        with open(LOG_FILE, 'w', encoding='utf-8') as f:
            json.dump(log_data, f, indent=2, ensure_ascii=False)

        self.log_message(f"Log saved to {LOG_FILE}", "SUCCESS")

    def run(self):
        """Lance l'interface"""
        self.log_message("AI Navigator initialized", "SUCCESS")
        self.log_message("Ready to monitor launcher", "INFO")
        self.root.mainloop()

if __name__ == "__main__":
    print("=" * 60)
    print("KOF Ultimate - AI Navigator")
    print("=" * 60)
    print()
    print("This AI agent will monitor the launcher in parallel")
    print("and detect all potential issues automatically.")
    print()

    navigator = LauncherAINavigator()
    navigator.run()
