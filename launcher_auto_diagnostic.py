"""
KOF Ultimate - Launcher avec Auto-Diagnostic
D√©tecte automatiquement les probl√®mes et corrige ce qui peut l'√™tre
"""

import os
import sys
import subprocess
import time
from pathlib import Path

class SmartLauncher:
    """Launcher intelligent avec auto-diagnostic et correction"""

    def __init__(self):
        self.base_path = Path("D:/KOF Ultimate")
        self.errors = []
        self.warnings = []
        self.fixes = []

    def log(self, message, level="INFO"):
        """Log avec couleurs"""
        colors = {
            "INFO": "",
            "SUCCESS": "‚úì ",
            "WARNING": "‚ö†Ô∏è  ",
            "ERROR": "‚ùå ",
            "FIX": "üîß "
        }
        prefix = colors.get(level, "")
        print(f"{prefix}{message}")

    def check_mugen_engine(self):
        """V√©rifie que MUGEN est disponible"""
        self.log("\nüì¶ V√©rification M.U.G.E.N...", "INFO")

        exe_path = self.base_path / "KOF BLACK R.exe"
        data_path = self.base_path / "data"
        cfg_path = self.base_path / "data/mugen.cfg"

        all_ok = True

        if not exe_path.exists():
            self.log("  KOF BLACK R.exe: MANQUANT", "ERROR")
            self.errors.append("MUGEN executable missing")
            all_ok = False
        else:
            self.log("  KOF BLACK R.exe: OK", "SUCCESS")

        if not data_path.exists():
            self.log("  data/ folder: MANQUANT", "ERROR")
            self.errors.append("MUGEN data folder missing")
            all_ok = False
        else:
            self.log("  data/ folder: OK", "SUCCESS")

        if not cfg_path.exists():
            self.log("  mugen.cfg: MANQUANT", "WARNING")
            self.warnings.append("MUGEN config missing")
        else:
            self.log("  mugen.cfg: OK", "SUCCESS")

        return all_ok

    def check_ikemen_engine(self):
        """V√©rifie que Ikemen GO est disponible et r√©pare si n√©cessaire"""
        self.log("\nüì¶ V√©rification Ikemen GO...", "INFO")

        ikemen_path = self.base_path / "Ikemen_GO"
        exe_path = ikemen_path / "Ikemen_GO.exe"
        font_path = ikemen_path / "font"
        debug_font_path = ikemen_path / "font/debug.def"
        log_path = ikemen_path / "Ikemen.log"

        all_ok = True

        # V√©rifier l'ex√©cutable
        if not exe_path.exists():
            self.log("  Ikemen_GO.exe: MANQUANT", "ERROR")
            self.errors.append("Ikemen GO executable missing")
            all_ok = False
        else:
            self.log("  Ikemen_GO.exe: OK", "SUCCESS")

        # V√©rifier le dossier font
        if not font_path.exists():
            self.log("  font/ folder: MANQUANT", "ERROR")
            self.errors.append("Ikemen GO font folder missing")
            all_ok = False
        else:
            self.log("  font/ folder: OK", "SUCCESS")

            # V√©rifier debug.def
            if not debug_font_path.exists():
                self.log("  font/debug.def: MANQUANT - AUTO-FIX", "WARNING")
                self.auto_fix_debug_font(ikemen_path)
            else:
                self.log("  font/debug.def: OK", "SUCCESS")

        # V√©rifier le log d'erreurs pr√©c√©dent
        if log_path.exists():
            try:
                with open(log_path, 'r', encoding='utf-8', errors='ignore') as f:
                    log_content = f.read()

                if "error" in log_content.lower() or "can't load" in log_content.lower():
                    self.log("  Log d'erreur d√©tect√©", "WARNING")
                    self.warnings.append("Previous Ikemen GO errors detected")

                    # Afficher les derni√®res erreurs
                    lines = log_content.strip().split('\n')
                    if lines:
                        self.log("    Derni√®re erreur:", "INFO")
                        for line in lines[-5:]:
                            if line.strip():
                                self.log(f"      {line.strip()}", "WARNING")
            except:
                pass

        return all_ok

    def auto_fix_debug_font(self, ikemen_path):
        """Cr√©e automatiquement le fichier debug.def manquant"""
        try:
            debug_font_path = ikemen_path / "font/debug.def"

            debug_content = """[FNT v2]
; FNT v2 version number.  Don't change this.
fntversion = 2,00
; Name of this font.
name = "Debug Font"
; This font is used for debug display

[Def]
; This is a bitmap font
Type = bitmap
; Size of font: width, height.  Width is used for spaces.
Size = 3,6
; Spacing between font glyphs: width, height.
Spacing = 1,0
; Drawing offset: x, y.
Offset = 0,1
; Filename of the sff containing the glyphs.  Use sff v2 only.
File = f-4x6.sff

; Note: All units are in pixels.
; Text rendered with bitmap fonts may be in ASCII only.
"""

            with open(debug_font_path, 'w', encoding='utf-8') as f:
                f.write(debug_content)

            self.log("  ‚úì debug.def cr√©√© automatiquement", "FIX")
            self.fixes.append("Created missing debug.def font file")
            return True
        except Exception as e:
            self.log(f"  ‚ùå Impossible de cr√©er debug.def: {e}", "ERROR")
            return False

    def launch_mugen(self):
        """Lance M.U.G.E.N"""
        self.log("\nüöÄ Lancement M.U.G.E.N...", "INFO")

        exe_path = self.base_path / "KOF BLACK R.exe"

        try:
            # Lancer le jeu
            subprocess.Popen([str(exe_path)], cwd=str(self.base_path))
            self.log("‚úì M.U.G.E.N lanc√© avec succ√®s!", "SUCCESS")
            return True
        except Exception as e:
            self.log(f"‚ùå Erreur au lancement: {e}", "ERROR")
            return False

    def launch_ikemen(self):
        """Lance Ikemen GO"""
        self.log("\nüöÄ Lancement Ikemen GO...", "INFO")

        ikemen_path = self.base_path / "Ikemen_GO"
        exe_path = ikemen_path / "Ikemen_GO.exe"
        log_path = ikemen_path / "Ikemen.log"

        # Supprimer l'ancien log pour voir les nouvelles erreurs
        if log_path.exists():
            try:
                log_path.unlink()
                self.log("  Ancien log supprim√©", "INFO")
            except:
                pass

        try:
            # Lancer le jeu
            process = subprocess.Popen([str(exe_path)], cwd=str(ikemen_path))

            # Attendre un peu pour voir si √ßa crash imm√©diatement
            time.sleep(2)

            # V√©rifier si le processus est encore en cours
            if process.poll() is not None:
                self.log("‚ö†Ô∏è  Ikemen GO s'est arr√™t√© imm√©diatement", "WARNING")

                # Lire le log d'erreur
                if log_path.exists():
                    self.log("\nüìã Log d'erreur:", "ERROR")
                    with open(log_path, 'r', encoding='utf-8', errors='ignore') as f:
                        print(f.read())

                return False
            else:
                self.log("‚úì Ikemen GO lanc√© avec succ√®s!", "SUCCESS")
                return True
        except Exception as e:
            self.log(f"‚ùå Erreur au lancement: {e}", "ERROR")
            return False

    def show_menu(self):
        """Affiche le menu principal"""
        print("\n")
        print("=" * 60)
        print("  üéÆ KOF ULTIMATE - LAUNCHER AUTO-DIAGNOSTIC")
        print("=" * 60)
        print()
        print("Ce launcher v√©rifie automatiquement tous les fichiers")
        print("et corrige ce qui peut l'√™tre avant de lancer le jeu.")
        print()

        # V√©rifications automatiques
        mugen_ok = self.check_mugen_engine()
        ikemen_ok = self.check_ikemen_engine()

        # R√©sum√©
        print()
        print("=" * 60)
        print("üìä R√âSUM√â DU DIAGNOSTIC")
        print("=" * 60)

        if self.fixes:
            self.log(f"\nüîß Corrections appliqu√©es: {len(self.fixes)}", "FIX")
            for fix in self.fixes:
                self.log(f"  ‚Ä¢ {fix}", "FIX")

        if self.warnings:
            self.log(f"\n‚ö†Ô∏è  Avertissements: {len(self.warnings)}", "WARNING")
            for warning in self.warnings:
                self.log(f"  ‚Ä¢ {warning}", "WARNING")

        if self.errors:
            self.log(f"\n‚ùå Erreurs critiques: {len(self.errors)}", "ERROR")
            for error in self.errors:
                self.log(f"  ‚Ä¢ {error}", "ERROR")

        if not self.errors and not self.warnings:
            self.log("\n‚úì Tout est OK! Tous les moteurs sont pr√™ts.", "SUCCESS")

        # Menu de choix
        print()
        print("=" * 60)
        print("MOTEURS DISPONIBLES:")
        print("=" * 60)
        print()

        if mugen_ok:
            print("  [1] ü•ä M.U.G.E.N (Classique) ‚úì")
        else:
            print("  [1] ü•ä M.U.G.E.N (Classique) ‚ùå NON DISPONIBLE")

        if ikemen_ok:
            print("  [2] üåê Ikemen GO (Moderne + Netplay) ‚úì")
        else:
            print("  [2] üåê Ikemen GO (Moderne + Netplay) ‚ö†Ô∏è  V√âRIFI√â")

        print()
        print("  [3] üîÑ Re-diagnostiquer")
        print("  [0] ‚ùå Quitter")
        print()

        return mugen_ok, ikemen_ok

    def run(self):
        """Boucle principale"""
        while True:
            # Reset des listes
            self.errors = []
            self.warnings = []
            self.fixes = []

            mugen_ok, ikemen_ok = self.show_menu()

            try:
                choice = input("Votre choix: ").strip()
            except KeyboardInterrupt:
                print("\n\nAu revoir!")
                sys.exit(0)

            if choice == "1":
                if mugen_ok:
                    self.launch_mugen()
                    print("\n")
                    input("Appuyez sur Entr√©e pour revenir au menu...")
                else:
                    self.log("\n‚ùå M.U.G.E.N n'est pas disponible", "ERROR")
                    print()
                    input("Appuyez sur Entr√©e pour continuer...")

            elif choice == "2":
                self.launch_ikemen()
                print("\n")
                input("Appuyez sur Entr√©e pour revenir au menu...")

            elif choice == "3":
                self.log("\nüîÑ Re-diagnostic en cours...", "INFO")
                time.sleep(1)
                continue

            elif choice == "0":
                print("\nüëã Au revoir!")
                break

            else:
                self.log("\n‚ùå Choix invalide", "ERROR")
                time.sleep(1)

if __name__ == "__main__":
    os.system("chcp 65001 > nul")  # UTF-8 pour Windows
    os.system("cls" if os.name == "nt" else "clear")

    launcher = SmartLauncher()
    launcher.run()
