#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
KOF ULTIMATE - Launcher Ultime V2
Version 2.0.0

Fonctionnalit√©s:
- Auto-MAJ automatique
- Auto-installation progressive
- Auto-r√©paration intelligente
- Jouer pendant l'installation
- V√©rification en temps r√©el
- Gestion compl√®te des d√©pendances
"""

import os
import sys
import json
import subprocess
import hashlib
import urllib.request
import zipfile
import shutil
from pathlib import Path
import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
from threading import Thread, Lock
import time
import webbrowser

# Configuration
VERSION = "2.0.0"
UPDATE_URL = "https://raw.githubusercontent.com/votre-repo/kof-ultimate/main/version.json"
GAME_PATH = Path(__file__).parent

class ProgressiveInstaller:
    """G√®re l'installation progressive en arri√®re-plan"""

    def __init__(self, callback=None):
        self.callback = callback
        self.is_running = False
        self.lock = Lock()
        self.essential_files = [
            "data/mugen.cfg",
            "data/fight.def",
            "data/select.def",
            "data/system.def"
        ]
        self.total_progress = 0
        self.current_task = ""

    def check_essential_files(self):
        """V√©rifie si les fichiers essentiels sont pr√©sents"""
        all_present = True
        missing = []

        for file_path in self.essential_files:
            full_path = GAME_PATH / file_path
            if not full_path.exists():
                all_present = False
                missing.append(file_path)

        return all_present, missing

    def can_play(self):
        """D√©termine si le jeu peut √™tre lanc√©"""
        essential_ok, _ = self.check_essential_files()
        exe_exists = (GAME_PATH / "KOF_Ultimate_Online.exe").exists()

        return essential_ok and exe_exists

    def install_in_background(self):
        """Lance l'installation en arri√®re-plan"""
        self.is_running = True

        def install_thread():
            try:
                self.update_status("Installation progressive d√©marr√©e...")

                # √âtape 1: Fichiers essentiels (haute priorit√©)
                self.update_status("Installation des fichiers essentiels...", 10)
                self.install_essential_files()

                # √âtape 2: Personnages principaux
                self.update_status("Installation des personnages...", 30)
                self.install_characters()

                # √âtape 3: Stages
                self.update_status("Installation des stages...", 60)
                self.install_stages()

                # √âtape 4: Ressources suppl√©mentaires
                self.update_status("Installation des ressources...", 80)
                self.install_resources()

                # √âtape 5: Finalisation
                self.update_status("Finalisation...", 95)
                self.finalize_installation()

                self.update_status("‚úì Installation compl√®te!", 100)

            except Exception as e:
                self.update_status(f"‚úó Erreur: {e}", -1)

            finally:
                self.is_running = False

        Thread(target=install_thread, daemon=True).start()

    def update_status(self, message, progress=None):
        """Met √† jour le statut de l'installation"""
        with self.lock:
            self.current_task = message
            if progress is not None:
                self.total_progress = progress

            if self.callback:
                self.callback(message, progress)

    def install_essential_files(self):
        """Installe les fichiers essentiels"""
        time.sleep(2)  # Simuler l'installation
        # TODO: Impl√©menter le t√©l√©chargement r√©el

    def install_characters(self):
        """Installe les personnages"""
        time.sleep(3)  # Simuler l'installation

    def install_stages(self):
        """Installe les stages"""
        time.sleep(2)

    def install_resources(self):
        """Installe les ressources"""
        time.sleep(1)

    def finalize_installation(self):
        """Finalise l'installation"""
        time.sleep(1)

class AutoRepair:
    """Syst√®me de r√©paration automatique"""

    def __init__(self, callback=None):
        self.callback = callback
        self.issues_found = []

    def diagnose(self):
        """Diagnostique les probl√®mes"""
        self.issues_found = []

        self.log("üîç Diagnostic en cours...")

        # V√©rifier l'ex√©cutable
        if not (GAME_PATH / "KOF_Ultimate_Online.exe").exists():
            self.issues_found.append({
                'type': 'missing_exe',
                'severity': 'critical',
                'description': 'Ex√©cutable du jeu manquant',
                'fixable': True
            })

        # V√©rifier les fichiers de configuration
        config_files = [
            "data/mugen.cfg",
            "data/select.def",
            "data/fight.def"
        ]

        for config_file in config_files:
            if not (GAME_PATH / config_file).exists():
                self.issues_found.append({
                    'type': 'missing_config',
                    'severity': 'high',
                    'description': f'Fichier de configuration manquant: {config_file}',
                    'file': config_file,
                    'fixable': True
                })

        # V√©rifier l'int√©grit√© des fichiers
        self.check_file_integrity()

        # V√©rifier les permissions
        self.check_permissions()

        return self.issues_found

    def check_file_integrity(self):
        """V√©rifie l'int√©grit√© des fichiers"""
        self.log("V√©rification de l'int√©grit√©...")

        # V√©rifier select.def
        select_file = GAME_PATH / "data" / "select.def"
        if select_file.exists():
            try:
                with open(select_file, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()

                if '[Characters]' not in content:
                    self.issues_found.append({
                        'type': 'corrupted_file',
                        'severity': 'high',
                        'description': 'select.def corrompu',
                        'file': 'data/select.def',
                        'fixable': True
                    })
            except:
                pass

    def check_permissions(self):
        """V√©rifie les permissions d'√©criture"""
        test_file = GAME_PATH / "write_test.tmp"

        try:
            test_file.write_text("test")
            test_file.unlink()
        except:
            self.issues_found.append({
                'type': 'permission_error',
                'severity': 'critical',
                'description': 'Permissions d\'√©criture insuffisantes',
                'fixable': False
            })

    def repair_all(self):
        """R√©pare tous les probl√®mes d√©tect√©s"""
        self.log(f"üîß R√©paration de {len(self.issues_found)} probl√®mes...")

        repaired = 0
        failed = 0

        for issue in self.issues_found:
            if not issue.get('fixable', False):
                continue

            try:
                if issue['type'] == 'missing_config':
                    self.repair_missing_config(issue['file'])
                    repaired += 1
                elif issue['type'] == 'corrupted_file':
                    self.repair_corrupted_file(issue['file'])
                    repaired += 1
                elif issue['type'] == 'missing_exe':
                    self.log("‚ö† Ex√©cutable manquant - t√©l√©chargement requis")
                    failed += 1
            except Exception as e:
                self.log(f"‚úó Erreur r√©paration: {e}")
                failed += 1

        self.log(f"‚úì R√©paration termin√©e: {repaired} r√©ussis, {failed} √©checs")
        return repaired, failed

    def repair_missing_config(self, file_path):
        """R√©pare un fichier de configuration manquant"""
        self.log(f"R√©paration: {file_path}")

        # Cr√©er le fichier avec configuration par d√©faut
        # TODO: Impl√©menter les configurations par d√©faut

    def repair_corrupted_file(self, file_path):
        """R√©pare un fichier corrompu"""
        self.log(f"R√©paration fichier corrompu: {file_path}")

        # TODO: Re-t√©l√©charger le fichier

    def log(self, message):
        """Log un message"""
        if self.callback:
            self.callback(message)

class UltimateLauncher:
    """Launcher ultime avec toutes les fonctionnalit√©s"""

    def __init__(self):
        self.root = tk.Tk()
        self.root.title(f"KOF Ultimate Launcher V2 - v{VERSION}")
        self.root.geometry("900x700")
        self.root.configure(bg='#0a0e27')

        # Composants
        self.installer = ProgressiveInstaller(self.on_install_progress)
        self.repairer = AutoRepair(self.log)

        # √âtat
        self.auto_repair_enabled = True
        self.can_play = False

        self.setup_ui()
        self.check_game_status()

        # Auto-diagnostic au d√©marrage
        Thread(target=self.auto_diagnostic, daemon=True).start()

    def setup_ui(self):
        """Configure l'interface"""
        # Header
        header = tk.Frame(self.root, bg='#1a1f3a', height=100)
        header.pack(fill=tk.X)
        header.pack_propagate(False)

        tk.Label(
            header,
            text="‚ö° KOF ULTIMATE LAUNCHER V2 ‚ö°",
            font=('Consolas', 28, 'bold'),
            fg='#FFD700',
            bg='#1a1f3a'
        ).pack(pady=(20, 5))

        tk.Label(
            header,
            text="‚îÅ‚îÅ AUTO-INSTALL ‚Ä¢ AUTO-UPDATE ‚Ä¢ AUTO-REPAIR ‚îÅ‚îÅ",
            font=('Consolas', 9),
            fg='#4a9eff',
            bg='#1a1f3a'
        ).pack()

        # Container principal
        main = tk.Frame(self.root, bg='#0d1b2a', padx=30, pady=20)
        main.pack(fill=tk.BOTH, expand=True)

        # Status du jeu
        status_frame = tk.LabelFrame(
            main,
            text=" üìä STATUT DU JEU ",
            font=('Consolas', 11, 'bold'),
            bg='#1b263b',
            fg='#00d9ff',
            padx=15,
            pady=15
        )
        status_frame.pack(fill=tk.X, pady=(0, 15))

        self.game_status_label = tk.Label(
            status_frame,
            text="üîç V√©rification...",
            font=('Consolas', 12),
            bg='#1b263b',
            fg='#ffaa00'
        )
        self.game_status_label.pack()

        # Boutons principaux
        buttons_frame = tk.Frame(main, bg='#0d1b2a')
        buttons_frame.pack(fill=tk.X, pady=10)

        # Bouton JOUER
        self.play_btn = tk.Button(
            buttons_frame,
            text="‚ñ∂‚ñ∂‚ñ∂  JOUER  ‚óÄ‚óÄ‚óÄ",
            font=('Consolas', 20, 'bold'),
            bg='#00cc44',
            fg='#000000',
            state=tk.DISABLED,
            cursor='hand2',
            command=self.launch_game,
            pady=15
        )
        self.play_btn.pack(fill=tk.X, pady=8)

        # Boutons secondaires - 2 colonnes
        secondary = tk.Frame(buttons_frame, bg='#0d1b2a')
        secondary.pack(fill=tk.X, pady=10)

        left = tk.Frame(secondary, bg='#0d1b2a')
        left.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 5))

        right = tk.Frame(secondary, bg='#0d1b2a')
        right.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(5, 0))

        # Boutons gauche
        tk.Button(
            left,
            text="üîß  R√©parer le jeu",
            font=('Consolas', 11, 'bold'),
            bg='#ff8800',
            fg='#000000',
            cursor='hand2',
            command=self.manual_repair,
            pady=10
        ).pack(fill=tk.X, pady=3)

        tk.Button(
            left,
            text="üì•  Installer/Mettre √† jour",
            font=('Consolas', 11, 'bold'),
            bg='#0088ff',
            fg='#ffffff',
            cursor='hand2',
            command=self.start_installation,
            pady=10
        ).pack(fill=tk.X, pady=3)

        # Boutons droite
        tk.Button(
            right,
            text="üë§  Personnages ({len(personnages)})",
            font=('Consolas', 11, 'bold'),
            bg='#9900ff',
            fg='#ffffff',
            cursor='hand2',
            command=self.show_characters,
            pady=10
        ).pack(fill=tk.X, pady=3)

        tk.Button(
            right,
            text="üîç  Inspecteur Visuel",
            font=('Consolas', 11, 'bold'),
            bg='#ff0088',
            fg='#ffffff',
            cursor='hand2',
            command=self.launch_inspector,
            pady=10
        ).pack(fill=tk.X, pady=3)

        # Progression
        progress_frame = tk.LabelFrame(
            main,
            text=" üìà PROGRESSION ",
            font=('Consolas', 11, 'bold'),
            bg='#1b263b',
            fg='#00d9ff',
            padx=15,
            pady=15
        )
        progress_frame.pack(fill=tk.X, pady=15)

        self.progress_label = tk.Label(
            progress_frame,
            text="En attente...",
            font=('Consolas', 10),
            bg='#1b263b',
            fg='#ffffff'
        )
        self.progress_label.pack(pady=(0, 10))

        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(
            progress_frame,
            variable=self.progress_var,
            maximum=100,
            length=400
        )
        self.progress_bar.pack(fill=tk.X)

        # Log
        log_frame = tk.LabelFrame(
            main,
            text=" üìã JOURNAL ",
            font=('Consolas', 11, 'bold'),
            bg='#1b263b',
            fg='#00d9ff',
            padx=10,
            pady=10
        )
        log_frame.pack(fill=tk.BOTH, expand=True, pady=(15, 0))

        self.log_text = scrolledtext.ScrolledText(
            log_frame,
            font=('Consolas', 9),
            bg='#1a1f3a',
            fg='#00ff88',
            height=10,
            wrap=tk.WORD
        )
        self.log_text.pack(fill=tk.BOTH, expand=True)

        # Status bar
        self.status_bar = tk.Label(
            self.root,
            text="‚ö° Pr√™t",
            font=('Consolas', 10, 'bold'),
            bg='#1a1f3a',
            fg='#00ff88',
            anchor=tk.W,
            padx=15,
            pady=5
        )
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)

    def log(self, message):
        """Ajoute un message au log"""
        timestamp = time.strftime("%H:%M:%S")
        self.log_text.insert(tk.END, f"[{timestamp}] {message}\n")
        self.log_text.see(tk.END)
        self.root.update()

    def check_game_status(self):
        """V√©rifie le statut du jeu"""
        self.can_play = self.installer.can_play()

        if self.can_play:
            self.game_status_label.config(
                text="‚úì Jeu pr√™t √† √™tre lanc√©",
                fg='#00ff88'
            )
            self.play_btn.config(state=tk.NORMAL)
            self.log("‚úì Le jeu est pr√™t!")
        else:
            essential_ok, missing = self.installer.check_essential_files()

            if not essential_ok:
                self.game_status_label.config(
                    text=f"‚ö† Installation requise ({len(missing)} fichiers manquants)",
                    fg='#ffaa00'
                )
                self.log(f"‚ö† {len(missing)} fichiers essentiels manquants")
            else:
                self.game_status_label.config(
                    text="‚ö† Installation incompl√®te",
                    fg='#ffaa00'
                )

            self.play_btn.config(state=tk.DISABLED)

    def auto_diagnostic(self):
        """Diagnostic automatique au d√©marrage"""
        time.sleep(1)

        self.log("üîç Diagnostic automatique...")

        issues = self.repairer.diagnose()

        if issues:
            self.log(f"‚ö† {len(issues)} probl√®mes d√©tect√©s")

            critical = [i for i in issues if i['severity'] == 'critical']
            if critical and self.auto_repair_enabled:
                self.log("üîß R√©paration automatique...")
                self.repairer.repair_all()
                self.check_game_status()
        else:
            self.log("‚úì Aucun probl√®me d√©tect√©")

    def manual_repair(self):
        """R√©paration manuelle"""
        self.log("üîß R√©paration manuelle d√©marr√©e...")

        self.progress_label.config(text="Diagnostic en cours...")
        self.progress_var.set(20)

        issues = self.repairer.diagnose()

        self.progress_var.set(50)

        if not issues:
            self.log("‚úì Aucun probl√®me d√©tect√©")
            messagebox.showinfo("Diagnostic", "Aucun probl√®me d√©tect√©!\nLe jeu est en bon √©tat.")
            self.progress_var.set(0)
            self.progress_label.config(text="Termin√©")
            return

        # Afficher les probl√®mes
        msg = f"{len(issues)} probl√®mes d√©tect√©s:\n\n"
        for i, issue in enumerate(issues[:5], 1):
            msg += f"{i}. {issue['description']}\n"

        if len(issues) > 5:
            msg += f"\n... et {len(issues) - 5} autres"

        msg += f"\n\nR√©parer maintenant?"

        if messagebox.askyesno("Probl√®mes d√©tect√©s", msg):
            self.progress_label.config(text="R√©paration...")
            self.progress_var.set(75)

            repaired, failed = self.repairer.repair_all()

            self.progress_var.set(100)
            self.progress_label.config(text=f"Termin√©: {repaired} r√©par√©s, {failed} √©checs")

            self.check_game_status()

            messagebox.showinfo(
                "R√©paration termin√©e",
                f"R√©paration termin√©e!\n\n{repaired} probl√®mes r√©par√©s\n{failed} √©checs"
            )

    def start_installation(self):
        """D√©marre l'installation progressive"""
        if self.installer.is_running:
            self.log("‚ö† Installation d√©j√† en cours")
            return

        self.log("üì• D√©marrage de l'installation progressive...")
        self.installer.install_in_background()

    def on_install_progress(self, message, progress):
        """Callback de progression de l'installation"""
        self.progress_label.config(text=message)

        if progress is not None and progress >= 0:
            self.progress_var.set(progress)

        self.log(message)

        # V√©rifier si on peut jouer
        if self.installer.can_play() and not self.can_play:
            self.can_play = True
            self.play_btn.config(state=tk.NORMAL)
            self.game_status_label.config(
                text="‚úì Jeu jouable (installation continue en arri√®re-plan)",
                fg='#00ff88'
            )
            self.log("‚úì Le jeu est maintenant jouable!")
            self.log("‚Ñπ L'installation continue en arri√®re-plan...")

    def launch_game(self):
        """Lance le jeu"""
        exe_path = GAME_PATH / "KOF_Ultimate_Online.exe"

        if not exe_path.exists():
            messagebox.showerror("Erreur", "Ex√©cutable non trouv√©!")
            return

        self.log("üéÆ Lancement du jeu...")

        try:
            subprocess.Popen([str(exe_path)], cwd=str(GAME_PATH))
            self.status_bar.config(text="‚úì Jeu lanc√©")
            self.root.iconify()
        except Exception as e:
            self.log(f"‚úó Erreur: {e}")
            messagebox.showerror("Erreur", f"Impossible de lancer le jeu:\n{e}")

    def show_characters(self):
        """Affiche le dashboard des personnages"""
        dashboard = GAME_PATH / "character_dashboard.py"

        if dashboard.exists():
            subprocess.Popen([sys.executable, str(dashboard)])
            self.log("‚úì Dashboard personnages lanc√©")
        else:
            self.log("‚úó Dashboard non trouv√©")

    def launch_inspector(self):
        """Lance l'inspecteur visuel"""
        inspector = GAME_PATH / "visual_inspector.py"

        if inspector.exists():
            subprocess.Popen([sys.executable, str(inspector)])
            self.log("‚úì Inspecteur visuel lanc√©")
        else:
            self.log("‚úó Inspecteur non trouv√©")

    def run(self):
        """Lance le launcher"""
        self.root.mainloop()

if __name__ == "__main__":
    app = UltimateLauncher()
    app.run()
